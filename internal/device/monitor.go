package device

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os/exec"
	"strings"
	"sync"
	"time"

	"mac-provisioner/internal/config"
)

const (
	EventConnected    = "connected"
	EventDisconnected = "disconnected"
	EventStateChanged = "state_changed"
)

type Event struct {
	Type   string  `json:"type"`
	Device *Device `json:"device"`
}

type Monitor struct {
	config       config.MonitoringConfig
	eventChan    chan Event
	devices      map[string]*Device // key = Device.UniqueID()
	devicesMutex sync.RWMutex
	running      bool
	ctx          context.Context
	cancel       context.CancelFunc
	firstScan    bool
}

func NewMonitor(cfg config.MonitoringConfig) *Monitor {
	return &Monitor{
		config:    cfg,
		eventChan: make(chan Event, cfg.EventBufferSize),
		devices:   make(map[string]*Device),
		firstScan: true,
	}
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ Apple-USB (ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ñ dfu/manager.go)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const (
	appleVendorIDHex    = "0x05ac"
	appleVendorIDString = "apple_vendor_id"
	appleManufacturer   = "Apple Inc."

	// DFU / Recovery PID
	dfuModePIDAS      = "0x1281"
	recoveryModePIDAS = "0x1280"
	dfuModePIDIntelT2 = "0x1227"
)

type SPUSBItem struct {
	Name         string      `json:"_name"`
	ProductID    string      `json:"product_id,omitempty"`
	VendorID     string      `json:"vendor_id,omitempty"`
	SerialNum    string      `json:"serial_num,omitempty"`
	LocationID   string      `json:"location_id,omitempty"`
	Manufacturer string      `json:"manufacturer,omitempty"`
	SubItems     []SPUSBItem `json:"_items,omitempty"`
}

type SPUSBDataType struct {
	Items []SPUSBItem `json:"SPUSBDataType"`
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Helpers (ECID, Mac detection, â€¦)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func extractECIDFromString(s string) string {
	marker := "ECID:"
	idx := strings.Index(s, marker)
	if idx == -1 {
		return ""
	}
	sub := s[idx+len(marker):]
	if end := strings.Index(sub, " "); end != -1 {
		sub = sub[:end]
	}
	return strings.TrimSpace(sub)
}

func isAppleDevice(item *SPUSBItem) bool {
	return strings.EqualFold(item.VendorID, appleVendorIDHex) ||
		strings.EqualFold(item.VendorID, appleVendorIDString) ||
		strings.Contains(item.Manufacturer, appleManufacturer)
}

func isDFURecoveryByPID(productID string) (bool, string, string) {
	switch strings.ToLower(productID) {
	case dfuModePIDAS:
		return true, "DFU", "Apple Silicon (DFU Mode)"
	case recoveryModePIDAS:
		return true, "Recovery", "Apple Silicon (Recovery Mode)"
	case dfuModePIDIntelT2:
		return true, "DFU", "Intel T2 (DFU Mode)"
	}
	return false, "", ""
}

func isDFURecoveryByName(name string) (bool, string) {
	l := strings.ToLower(name)
	if strings.Contains(l, "dfu mode") {
		return true, "DFU"
	}
	if strings.Contains(l, "recovery mode") {
		return true, "Recovery"
	}
	return false, ""
}

// ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Mac?
func isNormalMacDevice(item *SPUSBItem) bool {
	if !isAppleDevice(item) {
		return false
	}

	if isDFU, _, _ := isDFURecoveryByPID(item.ProductID); isDFU {
		return false
	}
	if isDFU, _ := isDFURecoveryByName(item.Name); isDFU {
		return false
	}

	nameLower := strings.ToLower(item.Name)
	for _, kw := range []string{"macbook", "imac", "mac mini", "mac studio", "mac pro"} {
		if strings.Contains(nameLower, kw) {
			return true
		}
	}
	// fallback â€“ Apple + ĞµÑÑ‚ÑŒ SerialNum (Ğ½Ğ¾ Ğ¾Ğ½ Ğ½Ğ°Ğ¼ Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½ Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ)
	return item.SerialNum != "" && isAppleDevice(item)
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Public
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func (m *Monitor) Start(ctx context.Context) error {
	if m.running {
		return fmt.Errorf("Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€ ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")
	}
	m.running = true
	m.ctx, m.cancel = context.WithCancel(ctx)

	log.Println("ğŸ” Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° USB-ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ² (system_profiler)â€¦")

	if err := m.initialScan(); err != nil {
		log.Printf("âš ï¸ ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: %v", err)
	}

	go m.monitorLoop()
	go m.cleanupLoop()

	log.Println("âœ… ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ USB-ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ² Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")
	return nil
}

func (m *Monitor) Stop() {
	if !m.running {
		return
	}
	log.Println("ğŸ›‘ ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° USB")
	m.running = false
	if m.cancel != nil {
		m.cancel()
	}
}

func (m *Monitor) Events() <-chan Event { return m.eventChan }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Loops
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func (m *Monitor) monitorLoop() {
	ticker := time.NewTicker(m.config.CheckInterval)
	defer ticker.Stop()
	log.Printf("ğŸ”„ Ğ¦Ğ¸ĞºĞ» Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ %v", m.config.CheckInterval)

	for {
		select {
		case <-m.ctx.Done():
			log.Println("ğŸ›‘ Ğ¦Ğ¸ĞºĞ» Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½")
			return
		case <-ticker.C:
			m.checkDevices()
		}
	}
}

func (m *Monitor) cleanupLoop() {
	t := time.NewTicker(m.config.CleanupInterval)
	defer t.Stop()

	for {
		select {
		case <-m.ctx.Done():
			return
		case <-t.C:
			m.devicesMutex.RLock()
			log.Printf("ğŸ§¹ Ğ¡Ğ»ĞµĞ´Ğ¸Ğ¼ Ğ·Ğ° %d ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°Ğ¼Ğ¸", len(m.devices))
			m.devicesMutex.RUnlock()
		}
	}
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Core
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func (m *Monitor) checkDevices() {
	current := m.fetchCurrentUSBDevices()

	m.devicesMutex.Lock()
	defer m.devicesMutex.Unlock()

	nowMap := make(map[string]*Device, len(current))
	for _, dev := range current {
		if uid := dev.UniqueID(); uid != "" {
			nowMap[uid] = dev
		}
	}

	if m.firstScan {
		for uid, dev := range nowMap {
			m.devices[uid] = dev
			m.sendEvent(Event{Type: EventConnected, Device: dev})
		}
		m.firstScan = false
		return
	}

	// 1. New + state-changed
	for uid, cur := range nowMap {
		old, exists := m.devices[uid]
		if !exists {
			m.devices[uid] = cur
			m.sendEvent(Event{Type: EventConnected, Device: cur})
			continue
		}
		if old.State != cur.State || old.IsDFU != cur.IsDFU || old.ECID != cur.ECID {
			m.devices[uid] = cur
			m.sendEvent(Event{Type: EventStateChanged, Device: cur})
		}
	}

	// 2. Disconnected
	for uid, old := range m.devices {
		if _, ok := nowMap[uid]; !ok {
			delete(m.devices, uid)
			m.sendEvent(Event{Type: EventDisconnected, Device: old})
		}
	}
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// system_profiler parsing
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func (m *Monitor) fetchCurrentUSBDevices() []*Device {
	cmd := exec.CommandContext(m.ctx, "system_profiler", "SPUSBDataType", "-json")
	var out, stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		if m.ctx.Err() == context.Canceled {
			return nil
		}
		log.Printf("âŒ system_profiler: %v â€“ %s", err, stderr.String())
		return nil
	}

	var data SPUSBDataType
	if err := json.Unmarshal(out.Bytes(), &data); err != nil {
		log.Printf("âŒ JSON parse: %v", err)
		return nil
	}

	var list []*Device
	for i := range data.Items {
		m.extractDevicesRecursively(&data.Items[i], &list)
	}
	return list
}

func (m *Monitor) extractDevicesRecursively(sp *SPUSBItem, acc *[]*Device) {
	if !isAppleDevice(sp) {
		for i := range sp.SubItems {
			m.extractDevicesRecursively(&sp.SubItems[i], acc)
		}
		return
	}

	var dev *Device

	// DFU / Recovery
	if isDFU, state, model := isDFURecoveryByPID(sp.ProductID); isDFU {
		dev = &Device{
			Model:       model,
			State:       state,
			IsDFU:       true,
			USBLocation: sp.LocationID,
		}
		if ecid := extractECIDFromString(sp.SerialNum); ecid != "" {
			dev.ECID = ecid
		} else {
			log.Printf("âš ï¸ DFU Ğ±ĞµĞ· ECID (%s) â€“ Ğ¸Ğ³Ğ½Ğ¾Ñ€.", model)
			dev = nil
		}
	} else if isDFU, state := isDFURecoveryByName(sp.Name); isDFU {
		dev = &Device{
			Model:       sp.Name,
			State:       state,
			IsDFU:       true,
			USBLocation: sp.LocationID,
		}
		if ecid := extractECIDFromString(sp.SerialNum); ecid != "" {
			dev.ECID = ecid
		} else {
			log.Printf("âš ï¸ DFU Ğ±ĞµĞ· ECID (%s) â€“ Ğ¸Ğ³Ğ½Ğ¾Ñ€.", sp.Name)
			dev = nil
		}
	} else if isNormalMacDevice(sp) {
		dev = &Device{
			Model:       sp.Name,
			State:       "Normal",
			IsDFU:       false,
			USBLocation: sp.LocationID,
		}
	}

	if dev != nil && dev.UniqueID() != "" {
		*acc = append(*acc, dev)
		log.Printf("ğŸ” ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¾: %s, UID=%s", dev.GetFriendlyName(), dev.UniqueID())
	}

	for i := range sp.SubItems {
		m.extractDevicesRecursively(&sp.SubItems[i], acc)
	}
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Utils
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func (m *Monitor) sendEvent(e Event) {
	to := time.NewTimer(100 * time.Millisecond)
	defer to.Stop()

	select {
	case m.eventChan <- e:
	case <-m.ctx.Done():
		log.Println("â„¹ï¸ ĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ cancel, ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾.")
	case <-to.C:
		log.Printf("âš ï¸ Ğ‘ÑƒÑ„ĞµÑ€ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ»Ğ½ĞµĞ½, %s Ğ´Ğ»Ñ %s Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾.",
			e.Type, e.Device.GetFriendlyName())
	}
}

func (m *Monitor) initialScan() error {
	log.Println("ğŸ” ĞŸĞµÑ€Ğ²Ğ¾Ğµ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ USBâ€¦")
	devs := m.fetchCurrentUSBDevices()
	m.devicesMutex.Lock()
	defer m.devicesMutex.Unlock()

	dfu, normal := 0, 0
	for _, d := range devs {
		uid := d.UniqueID()
		m.devices[uid] = d
		if d.IsDFU {
			dfu++
		} else {
			normal++
		}
	}
	log.Printf("âœ… ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾: %d DFU + %d Normal", dfu, normal)
	return nil
}

// GetConnectedDevices â€“ ĞºĞ¾Ğ¿Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°.
func (m *Monitor) GetConnectedDevices() []*Device {
	m.devicesMutex.RLock()
	defer m.devicesMutex.RUnlock()

	out := make([]*Device, 0, len(m.devices))
	for _, d := range m.devices {
		c := *d
		out = append(out, &c)
	}
	return out
}
