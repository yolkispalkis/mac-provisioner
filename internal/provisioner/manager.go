package provisioner

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"log"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"mac-provisioner/internal/device"
	"mac-provisioner/internal/dfu"
	"mac-provisioner/internal/notification"
	"mac-provisioner/internal/stats"
)

/*
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

	STRUCT
	â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*/
type Manager struct {
	dfuManager   *dfu.Manager
	notifier     *notification.Manager
	stats        *stats.Manager
	processing   map[string]bool // key = Device.UniqueID()
	processingMu sync.RWMutex
}

func New(dfuMgr *dfu.Manager, notifier *notification.Manager, stats *stats.Manager) *Manager {
	return &Manager{
		dfuManager: dfuMgr,
		notifier:   notifier,
		stats:      stats,
		processing: make(map[string]bool),
	}
}

/*
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

	PUBLIC
	â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*/
func (m *Manager) ProcessDevice(ctx context.Context, dev *device.Device) {
	uid := dev.UniqueID()

	// Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€
	m.processingMu.Lock()
	if m.processing[uid] {
		m.processingMu.Unlock()
		log.Printf("â„¹ï¸ Ğ£Ğ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ: %s", dev.GetFriendlyName())
		return
	}
	m.processing[uid] = true
	m.processingMu.Unlock()

	defer func() {
		m.processingMu.Lock()
		delete(m.processing, uid)
		m.processingMu.Unlock()
	}()

	log.Printf("ğŸš€ Ğ¡Ñ‚Ğ°Ñ€Ñ‚ Ğ¿Ñ€Ğ¾ÑˆĞ¸Ğ²ĞºĞ¸: %s (ECID:%s)", dev.GetFriendlyName(), dev.ECID)
	start := time.Now()
	m.stats.DeviceStarted()

	if !dev.IsDFU || dev.ECID == "" {
		errMsg := "ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ½Ğµ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¾ Ğº Ğ¿Ñ€Ğ¾ÑˆĞ¸Ğ²ĞºĞµ (Ğ½ĞµÑ‚ DFU Ğ¸Ğ»Ğ¸ ECID)"
		log.Printf("âŒ %s: %s", dev.GetFriendlyName(), errMsg)
		m.notifier.RestoreFailed(dev, errMsg)
		m.stats.DeviceCompleted(false, time.Since(start))
		return
	}

	decECID, err := normalizeECIDForCfgutil(dev.ECID)
	if err != nil {
		m.notifier.RestoreFailed(dev, "Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ ECID")
		m.stats.DeviceCompleted(false, time.Since(start))
		return
	}

	m.notifier.StartingRestore(dev)

	// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	// cfgutil restore  (Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°)
	// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	restoreCtx, cancel := context.WithTimeout(ctx, 15*time.Minute)
	defer cancel()

	cmd := exec.CommandContext(restoreCtx, "cfgutil", "--ecid", decECID, "restore")
	stdOut, _ := cmd.StdoutPipe()
	stdErr, _ := cmd.StderrPipe()

	if err := cmd.Start(); err != nil {
		log.Printf("âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ cfgutil: %v", err)
		m.notifier.RestoreFailed(dev, "Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ cfgutil")
		m.stats.DeviceCompleted(false, time.Since(start))
		return
	}

	// Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ²Ñ‹Ğ²Ğ¾Ğ´
	progressRx := regexp.MustCompile(`(?i)(progress|percent)[:\s]+(\d{1,3})%?`)
	go m.streamCfgutilOutput(dev, stdOut, progressRx)
	go m.streamCfgutilOutput(dev, stdErr, progressRx) // stderr Ğ¸Ğ½Ğ¾Ğ³Ğ´Ğ° ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ñ‚Ğ¾ Ğ¶Ğµ ÑĞ°Ğ¼Ğ¾Ğµ

	// Ğ¶Ğ´Ñ‘Ğ¼ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ
	waitErr := cmd.Wait()
	if waitErr != nil {
		if restoreCtx.Err() == context.DeadlineExceeded {
			m.notifier.RestoreFailed(dev, "Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚ cfgutil restore")
		} else {
			m.notifier.RestoreFailed(dev, waitErr.Error())
		}
		m.stats.DeviceCompleted(false, time.Since(start))
		return
	}
	log.Printf("âœ… cfgutil Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ğ»ÑÑ Ğ´Ğ»Ñ %s", dev.GetFriendlyName())

	// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	// Ğ¶Ğ´Ñ‘Ğ¼ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ° Ğ¸Ğ· DFU
	// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	if !m.waitExitDFU(ctx, decECID, 30*time.Second) {
		m.notifier.RestoreFailed(dev, "ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ Ğ² DFU Ğ¿Ğ¾ÑĞ»Ğµ restore")
		m.stats.DeviceCompleted(false, time.Since(start))
		return
	}

	log.Printf("ğŸ‰ ĞŸÑ€Ğ¾ÑˆĞ¸Ğ²ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°: %s", dev.GetFriendlyName())
	m.notifier.RestoreCompleted(dev)
	m.stats.DeviceCompleted(true, time.Since(start))
}

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Helpers
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

// Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ²Ñ‹Ğ²Ğ¾Ğ´ cfgutil Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½Ğ¾, Ğ´Ğ°Ñ‘Ñ‚ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ñ‹Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑĞµ
func (m *Manager) streamCfgutilOutput(dev *device.Device, r io.Reader, rx *regexp.Regexp) {
	sc := bufio.NewScanner(r)
	for sc.Scan() {
		line := sc.Text()
		if m.parseProgressLine(dev, line, rx) {
			continue // Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ ÑƒĞ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½
		}

		// Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹
		lc := strings.ToLower(line)
		switch {
		case strings.Contains(lc, "preparing"):
			m.notifier.RestoreProgress(dev, "Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°")
		case strings.Contains(lc, "downloading"):
			m.notifier.RestoreProgress(dev, "Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¿Ñ€Ğ¾ÑˆĞ¸Ğ²ĞºĞ¸")
		}
	}
}

// Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ true, ĞµÑĞ»Ğ¸ ÑÑ‚Ñ€Ğ¾ĞºĞ° ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ğ»Ğ° percent
func (m *Manager) parseProgressLine(dev *device.Device, line string, rx *regexp.Regexp) bool {
	if !rx.MatchString(line) {
		return false
	}
	matches := rx.FindStringSubmatch(line)
	if len(matches) < 3 {
		return false
	}
	percent := matches[2]
	m.notifier.RestoreProgress(dev, percent+" %")
	return true
}

// Ğ¶Ğ´Ñ‘Ğ¼, Ğ¿Ğ¾ĞºĞ° ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ²Ñ‹Ğ¹Ğ´ĞµÑ‚ Ğ¸Ğ· DFU
func (m *Manager) waitExitDFU(ctx context.Context, decimalECID string, max time.Duration) bool {
	waitCtx, cancel := context.WithTimeout(ctx, max)
	defer cancel()

	tick := time.NewTicker(3 * time.Second)
	defer tick.Stop()

	for {
		select {
		case <-waitCtx.Done():
			return false
		case <-tick.C:
			inDFU := false
			for _, d := range m.dfuManager.GetDFUDevices(waitCtx) {
				dec, _ := normalizeECIDForCfgutil(d.ECID)
				if dec == decimalECID {
					inDFU = true
					break
				}
			}
			if !inDFU {
				return true
			}
		}
	}
}

/*
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

	UTILITIES (Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹)
	â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*/
func hexToDec(hexStr string) (string, error) {
	clean := strings.TrimPrefix(strings.ToLower(hexStr), "0x")
	val, err := strconv.ParseUint(clean, 16, 64)
	if err != nil {
		return "", fmt.Errorf("Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³ HEX '%s': %w", hexStr, err)
	}
	return strconv.FormatUint(val, 10), nil
}

func isDigits(s string) bool {
	if s == "" {
		return false
	}
	for _, r := range s {
		if r < '0' || r > '9' {
			return false
		}
	}
	return true
}

func normalizeECIDForCfgutil(ecid string) (string, error) {
	if ecid == "" {
		return "", fmt.Errorf("ECID Ğ¿ÑƒÑÑ‚")
	}
	if isDigits(ecid) {
		return ecid, nil
	}
	if strings.HasPrefix(strings.ToLower(ecid), "0x") || !isDigits(ecid) {
		return hexToDec(ecid)
	}
	return "", fmt.Errorf("Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ ECID: %s", ecid)
}
